{"changed":true,"filter":false,"title":"main.c","tooltip":"/main.c","value":"/*Copyright (c) 2017,\n\n\tGuilherme Rodrigues \t     guilhermerodrigues10@gmail.com\n\tIlgner Lino Vieira           ilgner_lv@hotmail.com\n\tLucas Fran√ßoso Bataglia      lukao350@gmail.com\n \tLuciano Gabriel Francisco    lucianofl1@gmail.com\n \n   This file is part of Shellgas project.\n    \n   Shellgas is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n   ================================================================================\n   Shellgas source code may be obtained from (https://github.com/SO-II-2017/shellgas/)*/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <signal.h>\n\n#include \"foosh.h\"\n#include \"debug.h\"\n\n#define MAX_SIZE 1024\n#define PROMPT \"shellgas$ \"\n\n/* Structs */\n\nstruct command\n{\n    char **argv;\n};\n\ntypedef struct process_t\n{\n    pipeline_t process;\n    int pid;\n    int status; \t\t/* (0) running; (1) stopped/not running; */\n    int foreground; \t\t/* (0) background; (1) foreground; (-1) if it is not running */\n    char *processName;\n} process_t;\n\n/* Function's prototypes */\n\nint internal_commands(pipeline_t *internalPipeline); /*run all internal commands*/\nvoid execute_commands(pipeline_t *pipeline);\nint external_commands(pipeline_t *currentCommand);\nint external_pipes_commands(pipeline_t *currentCommand);\nvoid delFunc (void *func); /*function to delete nodes*/\nvoid childHandler(int sig); /*common child handler*/\nvoid childHandlerCtrlC(int sig);\nvoid childHandlerCtrlZ(int sig);\nvoid childHandlerEnd(int sig);\nint spawn_proc(int in, int out, struct command *cmd); /*functions to spawn processes [pipes]*/\nint fork_pipes(int n, struct command *cmd, pipeline_t *currentPipeline);\n\n\ntypedef void (*sighandler_t) (int);\n\nint go_on = 1;\t\t\t/* This variable controls the main loop. */\nlist_t *jobsList;\n\nint main (int argc, char **argv)\n{\n    buffer_t *command_line;\n    int aux;\n\n    pipeline_t *pipeline;\n    jobsList = new_list(delFunc);\n\n    command_line = new_command_line(); \t\t/* Read a Line */\n\n    pipeline = new_pipeline();\n\n    /* This is the main loop */\n    while (go_on)\n    {\n        char diretorio[3000];\n\n    printf(\"%s\", PROMPT);\n    \n    if (getcwd(diretorio, sizeof(diretorio)) != NULL) \n         \n        printf(\"/%s$ \", diretorio); \n        fflush(stdout);\n        fflush(stdin);\n\n        aux = read_command_line(command_line);\n\n        if (aux < 0)\n\t{\n            getchar();\n        }\n        else\n\t{\n            /* Parse (see the tparse.h file) */\n            if (!parse_command_line(command_line, pipeline) || 1)\n\t    {\n                execute_commands(pipeline); \t\t/* Execute commands in a pipeline */\n            }\n        }\n    }\n\n    release_command_line (command_line);\n    release_pipeline (pipeline);\n\n    return EXIT_SUCCESS;\n}\n\n\n/* Execute Commands Function */\n/* This function checks and separates the arguments and commands to send*/\n\nvoid execute_commands(pipeline_t *pipeline)\n{\n    int returning;\n\t// if there is more than one command on the command line\n    if (pipeline->ncommands > 1)\n    {\n        /* It is necessary to start execution of commands behind forward, that is, the last command to the end */\n        // Call the external command function\n        external_pipes_commands(pipeline);\n    }\n    else if (pipeline->ncommands == 0)\n\t{\n\t         /* If there is no any command, that is, only one was enter , nothing to do */\n\t}\n    else\n    {\n        //if there is a single command on the command line\n        if ((returning = internal_commands(pipeline)) == 1)\n\t{\n            returning = external_commands(pipeline);\n        }\n    }\n}\n\n/* External Pipes Commands Function */\n\nint external_pipes_commands(pipeline_t *currentCommand) {\n\n    pid_t pid;\n    int status;\n\n    struct command *cmd = malloc(sizeof(struct command) * currentCommand->ncommands);\n\n    /*command line array*/\n    int j;\n    for (j = 0; j < currentCommand->ncommands; j++) {\n        char **command_line = malloc(sizeof(char) * currentCommand->narguments[j] * 10);\n        /*organize command line array*/\n        int i;\n\t\t//put each argument in a vector, or makes a parse all arguments\n        for (i = 0; i < currentCommand->narguments[j]; i++) {\n            command_line[i] = currentCommand->command[j][i];\n        }\n        \n        /*last null*/\n        command_line[currentCommand->narguments[0]] = NULL;\n        \n        cmd[j].argv = command_line;\n    }\n    \n    pid = fork ();\n    fatal (pid < 0, \"Fork failed...\");\n    \n    if (pid == 0) {\n        fork_pipes(currentCommand->ncommands, cmd, currentCommand);\n    }\n    else {\n        wait(&status);\n    }\n    \n    return 0;\n}\n\n/* Spawn Process [Pipes] Function \n function that loads and executes a new child process. \n The current process may wait for the child to terminate or may continue to execute asynchronously. \n Creating a new subprocess requires enough memory in which both the child process and the current program can execute.\n*/\n\nint spawn_proc(int in, int out, struct command *cmd)\n{\n    pid_t pid;\n    \n    if ((pid = fork()) == 0)\n    {\n        if (in != 0)\n        {\n            dup2 (in, 0);\n            close (in);\n        }\n        \n        if (out != 1)\n        {\n            dup2 (out, 1);\n            close (out);\n        }\n        return execvp(cmd->argv [0], (char * const *)cmd->argv);\n    }\n    return pid;\n}\n\n/* Fork Pipes Function */\n/* This function taking all the arguments and separate commands of external commands\n* function and treat each of them according to the type of command it is (background, foreground, redirect stdout, in etc.)*/\n\nint fork_pipes (int n, struct command *cmd, pipeline_t *currentPipeline)\n{\n    int i;\n    int in;\n    int fd [2];\n    int fdopen;\n    \n    /* The first process should get its input from the original file descriptor 0.  */\n    in = 0;\n    \n    for (i = 0; i < n - 1; ++i)\n    {\n        pipe (fd);\n        \n        /* f [1] is the write end of the pipe*/\n        spawn_proc (in, fd [1], cmd + i);\n        \n        /*the child will write here.  */\n        close (fd [1]);\n        \n        /*the next child will read from there.  */\n        in = fd [0];\n    }\n    \n    /* Last stage of the pipeline*/\n    if (in != 0)\n        dup2 (in, 0);\n    \n    if (REDIRECT_STDOUT(currentPipeline)) \n    {\n        fdopen = open(currentPipeline->file_out, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n        \n        dup2(fdopen, STDOUT_FILENO);   /* make stdout go to file*/\n        dup2(fdopen, STDERR_FILENO); \n        close(fdopen);\n        \n    }\n    else if (REDIRECT_STDIN(currentPipeline)) \n    {\n        fdopen = open(currentPipeline->file_in, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n        \n        dup2(fdopen, STDIN_FILENO);   /* make stdin go to file */\n        dup2(fdopen, STDERR_FILENO);  \n        close(fdopen);\n    }\n\n    if (RUN_BACKGROUND(currentPipeline)) \n    {\n        int pid;\n        pid = fork();\n        \n        if (pid == 0) \n        {\n            execvp (cmd[i].argv [0], (char * const *)cmd [i].argv); /*running in child*/\n        }\n        else \n        {\n            list_node_t *node;\n            process_t *process;\n            char processName[100];\n            \n            node = append_node(jobsList);\n            \n            process = malloc(sizeof(process_t));\n            process->pid = pid;\n            process->process = *currentPipeline;\n            \n            process->processName = malloc(sizeof(char) * strlen(*cmd->argv));\n            \n            memcpy(processName, *cmd->argv, sizeof(cmd->argv));\n            processName[99] = '\\0';\n            \n            strcpy(process->processName, processName);\n            \n            process->status = 0;\n            process->foreground = 0;\n            \n            node->value = (void *)process;\n            \n            printf(\"[%d] %d\\n\", jobsList->size, process->pid);\n        }\n        \n        return pid;\n    }\n    else \n    {\n        return execvp (cmd[i].argv [0], (char * const *)cmd [i].argv);\n    }\n\n}\n\n/* Internal Commands Function */\n/* This function makes the signal processing such as killing processes zombies, running in foreground and background, job control, etc.)\n, ie, internal commands from a shell*/\n/*\n*   Internal commands are something which is built into the shell. For the shell built in commands, the execution speed is really high. \n    It is because no process needs to be spawned for executing it.\n    For example, when using the \"cd\" command, no process is created. The current directory simply gets changed on executing it.\n\tfonte: http://www.theunixschool.com/2012/03/internal-vs-external-commands.html\n*/\n\nint internal_commands(pipeline_t *internalPipeline) {\n    /*sanity test*/\n    if (internalPipeline->narguments[0] > 0) {\n        \n        /*check for each feature*/\n        if (strcmp(internalPipeline->command[0][0], \"exit\") == 0) {\n            go_on = 0;\n            kill(getppid(), SIGTERM);\n            return 0;\n        }\n        else if (strcmp(internalPipeline->command[0][0], \"fg\") == 0) {\n            if (internalPipeline->narguments[0] > 1) {\n                \n                list_node_t *node = jobsList->first;\n                \n                if (node != NULL) {\n                    int i = 0;\n                    for (i = 0; i < jobsList->size; i++) {\n                        \n                        process_t process = *((process_t*)node->value);\n                        \n                        if (strcmp(process.processName, internalPipeline->command[0][1]) == 0) {\n                            printf(\"%s\\n\", process.processName);\n                            \n                            process_t processAfter;\n                            list_node_t *newNode;\n                            int status;\n\n                            process_t *currentProcess = malloc(sizeof(process_t)); /*setting as the last!*/\n                            currentProcess->pid = process.pid;\n                            currentProcess->process = process.process;\n                            currentProcess->processName = process.processName;\n                            currentProcess->status = 0;\n                            currentProcess->foreground = 1;\n                            \n                            del_node(jobsList, node);\n                            \n                            newNode = append_node(jobsList);\n                            newNode->value = (void *)currentProcess;\n                            \n                            kill(process.pid, SIGCONT);\n                            \n                            waitpid(process.pid, &status, WUNTRACED);\n                            \n                            processAfter = *((process_t*)jobsList->last->value);\n                            \n                            if (WIFEXITED(status) == 1 && processAfter.status == 0) {\n                                del_node(jobsList, jobsList->last);  /*may not be the last one!*/\n                            }\n\n                            i = jobsList->size;\n                        }\n                        else {\n                            node = node->next;\n                        }\n                    }\n                }\n            }\n            else {\n                if (jobsList->last != NULL) {\n                    process_t *processAfter;\n                    \n                    process_t *process = ((process_t*)jobsList->last->value);\n                    process->status = 0;\n                    process->foreground = 1;\n                    \n                    printf(\"%s\\n\", process->processName);\n\n                    kill(process->pid, SIGCONT);\n                    \n                    int status;\n                    \n                    pid_t pid = process->pid;\n                    waitpid(pid, &status, WUNTRACED);\n                    \n                    if (jobsList->size > 0) {\n                        processAfter = ((process_t*)jobsList->last->value);\n                        \n                        /* status == 0 and foreground == 0 can be stopped on background, so we can't remove from jobs list*/\n                        if (WIFEXITED(status) == 1 && processAfter->status == 0 && processAfter->foreground == 1) {\n                            del_node(jobsList, jobsList->last);  /*may not be the last one!*/\n                        }\n                    }\n\n                }\n            }\n            \n            return 0;\n        }\n        else if (strcmp(internalPipeline->command[0][0], \"bg\") == 0) {\n            if (internalPipeline->narguments[0] > 1) {\n                list_node_t *node = jobsList->first;\n                \n                if (node != NULL) {\n                    int i;\n                    for (i = 0; i < jobsList->size; i++) {\n                        process_t *process = ((process_t*)node->value);\n                        \n                        /*continuing the process but not waiting (bg)*/\n                        if (strcmp(process->processName, internalPipeline->command[0][1]) == 0) {\n                            process->status = 0;\n                            process->foreground = 0;\n                            \n                            kill(process->pid, SIGCONT);\n                            \n                            signal(SIGCHLD, childHandler);\n                            \n                            printf(\"[%d] %d\\n\", jobsList->size, process->pid);\n                        }\n                        \n                        node = node->next;\n                    }\n                }\n            }\n            else {\n                if (jobsList->last != NULL) {\n                    process_t *process = ((process_t*)jobsList->last->value);\n                    process->status = 0;\n                    process->foreground = 0;\n                    \n                    kill(process->pid, SIGCONT);\n                    \n                    signal(SIGCHLD, childHandler);\n                }\n            }\n            \n            return 0;\n        }\n        else if (strcmp(internalPipeline->command[0][0], \"jobs\") == 0) {\n            if (jobsList->size > 0) {\n                list_node_t *node = jobsList->first;\n                \n                int i;\n                i = 1;\n                \n                while (node != NULL) {\n                    process_t process = *((process_t*)node->value);\n                    \n                    char *sign;\n                    sign = \"+\";\n                    \n                    if (i == jobsList->size - 1) {\n                        sign = \"-\";\n                    }\n                    else if (i != jobsList->size) {\n                        sign = \" \";\n                    }\n                    \n                    printf(\"\\n[%d]%s %s %d \\t %s\", i, sign, (process.status == 0) ? \"Running\":\"Stopped\", process.pid, process.processName);\n                    \n                    node = node->next;\n                    i++;\n                }\n                \n                printf(\"\\n\");\n            }\n            \n            \n            return 0;\n\n        }\n        else if (strcmp(internalPipeline->command[0][0], \"cd\") == 0) {\n            /*argument line array*/\n            int result;\n\t    result = chdir(internalPipeline->command[0][1]);\n            \n            if (result == 0) {\n                return 0;\n            }\n            else {\n                return -1;\n            }\n        }\n        \n        \n        return 1;\n    }\n    else {\n        return -1; /*error code*/\n    }\n}\n\n\n/* External Commands Function */\n/*\n\t External commands are not built into the shell. \n\t These are executables present in a separate file. \n\t When an external command has to be executed, a new process has to be spawned and the command gets executed.\n\t For example, when you execute the \"cat\" command, which usually is at /usr/bin, the executable /usr/bin/cat gets executed.\n\t fonte: http://www.theunixschool.com/2012/03/internal-vs-external-commands.html\n*/\nint external_commands(pipeline_t *currentCommand) {\n    int returning;\n    returning = -1;\n    \n    /*sanity test*/\n    if (currentCommand->narguments[0] > 0) {\n        int i;\n        pid_t pid;\n        int status;\n\n        /*command line array*/\n        char **command_line;\n        command_line = malloc(sizeof(char) * currentCommand->narguments[0] * 100);\n\t\n        /*organize command line array*/\n       \n        for (i = 0; i < currentCommand->narguments[0]; i++) {\n            command_line[i] = currentCommand->command[0][i];\n        }\n        \n        /*last null*/\n        command_line[currentCommand->narguments[0]] = NULL;\n        \n        /*create fork*/\n       \n        pid = fork ();\n        fatal (pid < 0, \"Fork failed...\");\n        \n        if (pid > 0) {\n            list_node_t *node = append_node(jobsList);\n            \n            struct sigaction actC;\n            struct sigaction actZ;\n            struct sigaction act;\n\n            void *temp;\n            void *temp2;\n            void *temp3;\n\n            process_t *process;\n\n            temp = memset(&actC, 0, sizeof(struct sigaction));\n            fatal (!temp, \"memset failed\");\n            actC.sa_handler = childHandlerCtrlC;\n            sigaction(SIGINT, &actC, NULL);\n            \n            temp2 = memset(&actZ, 0, sizeof(struct sigaction));\n            fatal (!temp2, \"memset failed\");\n            actZ.sa_handler = childHandlerCtrlZ;\n            sigaction(SIGTSTP, &actZ, NULL);\n            \n            temp3 = memset(&act, 0, sizeof(struct sigaction));\n            fatal (!temp3, \"memset failed\");\n            act.sa_handler = childHandlerEnd;\n            sigaction(SIGTERM, &act, NULL);\n            \n            struct sigaction actBG;\n            void *tempBG;\n            tempBG = memset(&actBG, 0, sizeof(struct sigaction));\n\n            process = malloc(sizeof(process_t));\n            process->pid = pid;\n            process->process = *currentCommand;\n            \n            process->processName = malloc(sizeof(char) * strlen(command_line[0]));            \n            strcpy(process->processName, command_line[0]);\n\n            process->status = 0;\n            \n            node->value = (void *)process;\n            \n            if (RUN_FOREGROUND(currentCommand)) {\n                process->foreground = 1;\n                \n                setpgid(pid, pid);\n                \n                waitpid(pid, &status, WUNTRACED);\n                \n                /*status == 0 and foreground == 0 can be stopped on background*/\n                if (WEXITSTATUS(status) == 0 && process->status == 0 && process->foreground == 1) {\n                    del_node(jobsList, jobsList->last);\n                }\n            }\n            else {\n                process->foreground = 0;\n                \n                if (process->status == 0 && process->foreground == 0) {\n                    printf(\"[%d] %d\\n\", jobsList->size, pid);\n                }\n                \n                fatal (!tempBG, \"memset failed\");\n                actBG.sa_handler = childHandler;\n                sigaction(SIGCHLD, &actBG, NULL);\n            }\n        }\n        else {\n            int returningCode;\n            setpgid(getpid(), pid);\n\n            if (REDIRECT_STDOUT(currentCommand)) {\n                int fd;\n                fd = open(currentCommand->file_out, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n                \n                dup2(fd, STDOUT_FILENO);   /* make stdout go to file*/\n                dup2(fd, STDERR_FILENO);   \n                \n                close(fd);\n            }\n            else if (REDIRECT_STDIN(currentCommand)) {\n                int fd;\n                fd = open(currentCommand->file_in, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n                \n                dup2(fd, STDIN_FILENO);   /* make stdout go to file*/\n                dup2(fd, STDERR_FILENO);  \n                \n                close(fd);\n            }\n\n            if ((returningCode = execvp(command_line[0], command_line)) < 0) {\n                kill(getpid(), SIGSYS);\n            }\n        }\n    }\n    \n    return returning;\n}\n\n/* this function is the case where the user press ctrl-c*/\nvoid childHandlerCtrlC(int sig) {\n    printf(\"ctrlc %s\\n\", ((process_t*)jobsList->last->value)->processName);\n    process_t *processValue = ((process_t*)jobsList->last->value);\n    \n    if (processValue != NULL) {\n        kill(processValue->pid, SIGINT);\n    }\n}\n\n/* this function is the case where the user closes the child process*/\nvoid childHandlerEnd(int sig) {\n    printf(\"end %d (%d) %s\", __LINE__, sig, ((process_t*)jobsList->last->value)->processName);\n    \n    process_t *processValue = ((process_t*)jobsList->last->value);\n    \n    if (processValue != NULL) {\n        kill(processValue->pid, SIGTERM);\n        \n        del_node(jobsList, jobsList->last);\n        printf(\"end %d\", __LINE__);\n    }\n}\n/* this function is the case where the user press ctrl-z*/\nvoid childHandlerCtrlZ(int sig) {\n    process_t *processValue = ((process_t*)jobsList->last->value);\n    char *sign;\n\n    processValue->status = 1;\n    processValue->foreground = 1; /*set as foreground because we don't know what the user may want*/\n    \n    kill(processValue->pid, SIGTSTP);\n    \n    sign = \"+\";\n    printf(\"\\n[%d]%s\\t Stopped \\t %s\\n\", jobsList->size, sign, processValue->processName);\n}\n\nvoid childHandler(int sig) {\n    char *sign;\n    int i;\n    int sanity = -1;\n    list_node_t *node;\n    process_t *process = NULL;\n\n    pid_t pid;\n    pid = wait(NULL);\n    \n    node = jobsList->first;    \n    \n    \n    /*loop to get the job in the jobs list*/\n    for (i = 0; i < jobsList->size; i++) {\n        process = ((process_t*)node->value);\n        \n        if (process->pid == pid) {\n            sanity = i;\n            i = jobsList->size;\n        }\n        else {\n            node = node->next;\n        }\n    }\n\n    \n    /*prepares the printf and deletenode if needed*/\n    if (process->foreground == 0) {\n        sign = \"+\";\n        \n        if (sanity == jobsList->size - 2) {\n            sign = \"-\";\n        }\n        else if (sanity != jobsList->size - 1) {\n            sign = \" \";\n        }\n        \n        if (WEXITSTATUS(sig) == 0) {\n            ((process_t*)node->value)->status = -1;\n            printf(\"[%d]%s\\t Done \\t %s\\n\", sanity+1, sign, process->processName);\n            del_node(jobsList, node);\n\n        }\n        else {\n            printf(\"[%d]%s\\t Stopped \\t %s\\n\", sanity+1, sign, process->processName);\n        }\n    }\n}\n\n/* Delete Node Function */\n\nvoid delFunc (void *func)\n{\n    free (func);\n}\n","undoManager":{"mark":-1,"position":-1,"stack":[]},"ace":{"folds":[],"scrolltop":1369,"scrollleft":0,"selection":{"start":{"row":98,"column":23},"end":{"row":98,"column":23},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1499174421318}